<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pinku Particle Universe</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            max-width: 300px;
        }
        
        h1 { margin: 0; font-size: 1.8rem; text-transform: uppercase; 
             background: linear-gradient(90deg, #ff00cc, #00ffff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        h2 { margin: 5px 0 15px 0; font-size: 1rem; color: #ccc; }

        .status-line { margin: 10px 0; font-size: 1.1rem; }
        #shape-name { color: #ffff00; font-weight: bold; text-shadow: 0 0 5px #ff0000; }

        #webcam-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            transform: scaleX(-1);
            border: 2px solid #00ffff;
            border-radius: 8px;
            opacity: 0.7;
        }

        .controls { margin-top: 15px; font-size: 0.85rem; color: #aaa; }
        .key { color: #fff; font-weight: bold; background: #333; padding: 2px 6px; border-radius: 4px; }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-container">
        <h1>Pinku Particles</h1>
        <h2>Ultimate Collection</h2>
        <div class="status-line">Model: <span id="shape-name">PINKU NAME</span></div>
        <hr style="border: 0; border-top: 1px solid #444;">
        <div class="controls">
            <p>üëã Move Hand to Rotate</p>
            <p>ü§è Pinch to Collapse</p>
            <p>‚úä <b>Make Fist</b> to Change Model</p>
        </div>
    </div>

    <video id="webcam-feed" autoplay playsinline></video>

<script>
    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 25000; // High count for detailed text
    const PARTICLE_SIZE = 0.07;
    const SMOOTHING = 0.07;
    
    // --- THREE.JS SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 18;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- PARTICLE SYSTEM ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
    
    // Initial Explosion
    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 100;
        targetPositions[i] = positions[i];
        colors[i] = 1.0;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.9
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);

    // --- SHAPE GENERATORS ---

    // 1. Text Generator for "PINKU"
    function getPinkuTextPoint(i) {
        // Simple grid-based font definition
        // 0=empty, 1=fill
        const P = [
            [1,1,1,1,0],
            [1,0,0,0,1],
            [1,1,1,1,0],
            [1,0,0,0,0],
            [1,0,0,0,0]
        ];
        const I = [
            [0,1,1,1,0],
            [0,0,1,0,0],
            [0,0,1,0,0],
            [0,0,1,0,0],
            [0,1,1,1,0]
        ];
        const N = [
            [1,0,0,0,1],
            [1,1,0,0,1],
            [1,0,1,0,1],
            [1,0,0,1,1],
            [1,0,0,0,1]
        ];
        const K = [
            [1,0,0,1,0],
            [1,0,1,0,0],
            [1,1,0,0,0],
            [1,0,1,0,0],
            [1,0,0,1,0]
        ];
        const U = [
            [1,0,0,0,1],
            [1,0,0,0,1],
            [1,0,0,0,1],
            [1,0,0,0,1],
            [0,1,1,1,0]
        ];

        const letters = [P, I, N, K, U];
        const spacing = 6;
        const scale = 0.8;
        const startX = -((letters.length * spacing) / 2) + 2;

        // Map particle index to a random spot in the text pixels
        const randomLetterIdx = i % letters.length;
        const letterGrid = letters[randomLetterIdx];
        
        let validPointFound = false;
        let px = 0, py = 0;

        // Try to find a filled pixel
        let attempt = 0;
        while(!validPointFound && attempt < 20) {
            const rRow = Math.floor(Math.random() * 5);
            const rCol = Math.floor(Math.random() * 5);
            if(letterGrid[rRow][rCol] === 1) {
                // Found a pixel, add some jitter to fill the volume
                px = (rCol * scale) + (startX + randomLetterIdx * spacing) + (Math.random()-0.5)*0.5;
                py = ((4-rRow) * scale) - 2 + (Math.random()-0.5)*0.5; // Invert Y because array is top-down
                validPointFound = true;
            }
            attempt++;
        }
        
        // If calculation failed, just return to center
        if(!validPointFound) return {x: (Math.random()-0.5)*20, y: (Math.random()-0.5)*20, z:0};

        return { x: px, y: py, z: (Math.random() - 0.5) * 1.5 }; // Slight depth
    }

    // 2. Sudarshan Chakra (Spiked Disc)
    function getSudarshanChakraPoint(i) {
        const angle = Math.random() * Math.PI * 2;
        // Base ring
        const rBase = 6 + Math.random() * 2;
        // Spikes (Sawtooth wave added to radius)
        const spikes = 16;
        const spikeHeight = Math.abs(Math.sin(angle * spikes)) * 2; 
        
        const r = rBase + spikeHeight;
        
        return {
            x: Math.cos(angle) * r,
            y: Math.sin(angle) * r,
            z: (Math.random() - 0.5) * 0.2 // Very thin
        };
    }

    // 3. Trishul (Trident)
    function getTrishulPoint(i) {
        const choice = Math.random();
        
        // Staff (Vertical line) - 60% of particles
        if (choice < 0.6) {
            return {
                x: (Math.random() - 0.5) * 0.4,
                y: (Math.random() * 16) - 10, // -10 to +6
                z: (Math.random() - 0.5) * 0.4
            };
        } 
        // Outer Prongs (Curved) - 20%
        else if (choice < 0.8) {
            const t = Math.random() * Math.PI; // 0 to PI (Arch)
            const xOffset = 3.5;
            const yOffset = 4; // Start near top of staff
            return {
                x: Math.cos(t) * 2.5 + (t > Math.PI/2 ? -2.5 : 2.5), // Approximating curves
                y: yOffset + Math.sin(t) * 4,
                z: (Math.random() - 0.5) * 0.3
            };
        }
        // Center Prong (Straight up) - 20%
        else {
            return {
                x: (Math.random() - 0.5) * 0.3,
                y: 6 + Math.random() * 4, // Above staff
                z: (Math.random() - 0.5) * 0.3
            };
        }
    }

    // 4. Brahmastra (Swirling Energy / Torus Knot)
    function getBrahmastraPoint(i) {
        // Parametric Equation for a Torus Knot (Energy Vortex)
        const t = (i / PARTICLE_COUNT) * Math.PI * 2 * 20; // Multiple windings
        const p = 2; // Winds around axis
        const q = 3; // Winds through hole
        
        const scale = 2.5;
        const r = 2 + Math.cos(q * t);
        
        return {
            x: scale * r * Math.cos(p * t) + (Math.random()-0.5),
            y: scale * r * Math.sin(p * t) + (Math.random()-0.5),
            z: scale * Math.sin(q * t) + (Math.random()-0.5)
        };
    }

    // 5. Aeroplane
    function getAeroplanePoint(i) {
        const r = Math.random();
        
        if (r < 0.5) {
            // Fuselage (Cylinder along Z)
            const len = 12;
            const z = (Math.random() * len) - (len/2);
            const rad = 1.2;
            const angle = Math.random() * Math.PI * 2;
            return {
                x: Math.cos(angle) * rad,
                y: Math.sin(angle) * rad,
                z: z
            };
        } else if (r < 0.8) {
            // Wings (Flat planes)
            const span = 14;
            const x = (Math.random() * span) - (span/2);
            const z = (Math.random() * 4) - 1; // Width of wing
            const y = 0;
            // Taper wings
            if (Math.abs(x) > 2) {
                // If far out, thin Z
                return { x: x, y: (Math.random()-0.5)*0.5, z: z * (1 - Math.abs(x)/span) };
            }
            return { x: x, y: 0, z: z };
        } else {
            // Tail
            return {
                x: (Math.random() - 0.5) * 5,
                y: Math.random() * 3,
                z: -5 + (Math.random() * 2)
            };
        }
    }

    // 6. Bow and Arrow
    function getBowAndArrowPoint(i) {
        const r = Math.random();
        
        if (r < 0.5) {
            // The Bow (Arc)
            const t = (Math.random() * Math.PI) - (Math.PI/2); // -PI/2 to PI/2
            const radius = 8;
            return {
                x: Math.cos(t) * 2, // Thickness
                y: Math.sin(t) * radius,
                z: (Math.random()-0.5) * 0.5
            };
        } else {
            // The Arrow (Line)
            const len = 10;
            const x = (Math.random() * len) - (len/2);
            // Arrowhead
            if (x > 3) {
                 return { x: x, y: (Math.random()-0.5) * (5-x), z: (Math.random()-0.5) * (5-x) };
            }
            return {
                x: x,
                y: 0,
                z: 0
            };
        }
    }

   // 7. Sphere
    function getSpherePoint(i) {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const r = 6; // Radius
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi)
        };
    }

    // 8. DNA Helix
    function getDNAPoint(i) {
        const len = 14;
        const y = ((i / PARTICLE_COUNT) * len) - (len/2); // Height from -7 to 7
        const radius = 3;
        const turns = 4; // How many twists
        const angle = y * turns;
        
        // Split particles into two strands (Double Helix)
        const offset = (i % 2 === 0) ? 0 : Math.PI; 
        
        // Add some random scatter for "dusty" look
        const scatter = (Math.random() - 0.5) * 0.5;

        return {
            x: Math.cos(angle + offset) * radius + scatter,
            y: y,
            z: Math.sin(angle + offset) * radius + scatter
        };
    }

    // 9. Quantum Cube
    function getQuantumCubePoint(i) {
        const size = 4;
        // Distribute randomly inside a box volume
        return {
            x: (Math.random() - 0.5) * 2 * size,
            y: (Math.random() - 0.5) * 2 * size,
            z: (Math.random() - 0.5) * 2 * size
        };
    }

    // 10. Ancient Pyramid
    function getPyramidPoint(i) {
        const height = 10;
        const y = (Math.random() * height) - (height/2); // Height from -5 to 5
        
        // Calculate width at this specific height (Taper towards top)
        // Normalize Y from 0 (bottom) to 1 (top)
        const normalizedY = (y + (height/2)) / height; 
        const baseSize = 7;
        // As we go up (normalizedY approaches 1), size approaches 0
        const currentSize = baseSize * (1 - normalizedY);

        return {
            x: (Math.random() - 0.5) * 2 * currentSize,
            y: y,
            z: (Math.random() - 0.5) * 2 * currentSize
        };
    }

    // 11. Heart
    function getHeartPoint(i) {
        const range = Math.PI * 2;
        const t = (Math.random() * range) - Math.PI;
        const scale = 0.35;
        
        // 2D Heart shape math
        const r = 16 * Math.pow(Math.sin(t), 3);
        const yBase = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        
        // Extrude to 3D
        const zOffset = (Math.random() - 0.5) * 4; 
        
        // Fill the volume slightly
        const scatter = 1 - Math.random() * 0.2; 

        return {
            x: r * scale * scatter,
            y: yBase * scale * scatter,
            z: zOffset
        };
    }

    // 12. Sine Wave
    function getSineWavePoint(i) {
        const size = 12;
        // Grid distribution usually looks better for waves, but random works for particles
        const x = (Math.random() - 0.5) * size;
        const z = (Math.random() - 0.5) * size;
        
        // The wave formula: Amplitude * sin(frequency * x)
        const y = Math.sin(x * 0.8) * Math.cos(z * 0.8) * 2.5;
        
        return { x, y, z };
    }

    // 13. Galaxy
    function getGalaxyPoint(i) {
        const arms = 3;
        const armIndex = i % arms;
        const randomOffset = Math.random();
        
        const maxR = 9;
        const r = randomOffset * maxR;
        
        // Logarithmic spiral math
        const spin = 3.5; 
        const angle = (r / maxR) * Math.PI * 2 * spin + (armIndex * (Math.PI * 2 / arms));
        
        // Add random scatter to make it look like a cloud, not a perfect line
        const scatter = (Math.random() - 0.5) * 0.5;
        
        return { 
            x: (Math.cos(angle) * r) + scatter, 
            y: (Math.random() - 0.5) * (maxR - r) * 0.4, // Bulge at center
            z: (Math.sin(angle) * r) + scatter
        };
    }
  
// --- MANAGER ---
    const shapes = [
        // Original Pinku & Weapon Models
        { name: 'PINKU (Name)', func: getPinkuTextPoint },
        { name: 'Sudarshan Chakra', func: getSudarshanChakraPoint },
        { name: 'Trishul (Shiva)', func: getTrishulPoint },
        { name: 'Brahmastra', func: getBrahmastraPoint },
        { name: 'Aeroplane', func: getAeroplanePoint },
        { name: 'Bow & Arrow', func: getBowAndArrowPoint },
        
        // New Mathematical Shapes (7-13)
        { name: 'Sphere', func: getSpherePoint },
        { name: 'DNA Helix', func: getDNAPoint },
        { name: 'Quantum Cube', func: getQuantumCubePoint },
        { name: 'Ancient Pyramid', func: getPyramidPoint },
        { name: 'Heart', func: getHeartPoint },
        { name: 'Sine Wave', func: getSineWavePoint },
        { name: 'Galaxy', func: getGalaxyPoint }
    ];

    let currentShapeIndex = 0;

    // Ensure Galaxy function is defined for the list
    function getGalaxyPoint(i) {
        const arms = 5;
        const armIndex = i % arms;
        const maxR = 9;
        const r = Math.random() * maxR;
        
        // Logarithmic spiral math
        const spin = 4.0; 
        const angle = (r / maxR) * Math.PI * 2 * spin + (armIndex * (Math.PI * 2 / arms));
        
        return { 
            x: Math.cos(angle) * r, 
            y: (Math.random() - 0.5) * (maxR - r) * 0.5, // Bulge at center
            z: Math.sin(angle) * r 
        };
    }

    function updateTargetShape() {
        const shapeObj = shapes[currentShapeIndex];
        document.getElementById('shape-name').innerText = shapeObj.name;
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // Execute the specific function for the current shape
            const p = shapeObj.func(i);
            
            targetPositions[i * 3] = p.x;
            targetPositions[i * 3 + 1] = p.y;
            targetPositions[i * 3 + 2] = p.z;
        }
        triggerColorPulse();
    }

    // Initialize with the first shape
    updateTargetShape();

    // --- INPUT HANDLING ---
    let pinchStrength = 0;
    let handX = 0, handY = 0;
    let isFist = false;
    let lastFistTime = 0;

    const videoElement = document.getElementById('webcam-feed');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });

    hands.onResults(onHandsResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320,
        height: 240
    });
    cameraUtils.start();

    function onHandsResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            
            // Pan/Rotate
            const x = (lm[8].x - 0.5) * 2;
            const y = -(lm[8].y - 0.5) * 2;
            handX += (x - handX) * 0.1;
            handY += (y - handY) * 0.1;

            // Pinch
            const d = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
            pinchStrength = 1 - Math.min(Math.max(d / 0.15, 0), 1);

            // Fist Logic (Fingers curled)
            let curled = 0;
            if (lm[12].y > lm[10].y) curled++; // Middle
            if (lm[16].y > lm[14].y) curled++; // Ring
            if (lm[20].y > lm[18].y) curled++; // Pinky
            if (lm[8].y > lm[6].y) curled++;   // Index

            const now = Date.now();
            if (curled >= 3) {
                if (!isFist && now - lastFistTime > 1500) {
                    currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
                    updateTargetShape();
                    lastFistTime = now;
                }
                isFist = true;
            } else {
                isFist = false;
            }
        }
    }

    function triggerColorPulse() {
        const c = geometry.attributes.color;
        const rOff = Math.random();
        const gOff = Math.random();
        
        for(let i=0; i<PARTICLE_COUNT; i++) {
            // Gold/Red/Orange themes for weapons, Blue/Pink for generic
            if(currentShapeIndex >= 1 && currentShapeIndex <= 3) {
                 // Mythological (Gold/Fire)
                 c.setXYZ(i, 1.0, 0.5 + Math.random()*0.5, 0.0);
            } else {
                 // Neon
                 c.setXYZ(i, Math.random(), 0.5 + Math.random()*0.5, 1.0);
            }
        }
        c.needsUpdate = true;
    }

    // --- ANIMATION ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        const pos = geometry.attributes.position.array;

        // Rotation
        particleSystem.rotation.y = -handX * 2 + time * 0.2;
        particleSystem.rotation.x = handY * 1.5;

        // Special rotation for Chakra
        if(shapes[currentShapeIndex].name === 'Sudarshan Chakra') {
            particleSystem.rotation.z += 0.1; // Spin fast
        }

        const expand = 1 + (1 - pinchStrength) * 4;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3;
            
            let tx = targetPositions[ix] * expand;
            let ty = targetPositions[ix+1] * expand;
            let tz = targetPositions[ix+2] * expand;

            // Explosion/Noise
            if (pinchStrength < 0.2) {
                tx += Math.sin(time * 5 + i) * 0.5;
                ty += Math.cos(time * 6 + i) * 0.5;
            }

            pos[ix] += (tx - pos[ix]) * SMOOTHING;
            pos[ix+1] += (ty - pos[ix+1]) * SMOOTHING;
            pos[ix+2] += (tz - pos[ix+2]) * SMOOTHING;
        }

        geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
