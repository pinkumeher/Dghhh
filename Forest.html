<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whispering Forest: Interactive AI Biome</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-input { position: absolute; top: 10px; left: 10px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); opacity: 0.5; border-radius: 8px; display: none; }
        #ui { position: absolute; bottom: 20px; left: 20px; color: #aaffcc; z-index: 3; pointer-events: none; text-shadow: 0 0 10px #aaffcc; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; z-index: 10; font-size: 24px; text-align: center; }
        .instruction { font-size: 14px; opacity: 0.8; margin-bottom: 5px; }
        .state-indicator { font-weight: bold; color: #fff; font-size: 18px; }
    </style>
    <!-- Import Three.js and MediaPipe via Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="loading">Initialize Neural Link...<br><span style="font-size:14px; opacity:0.6">Allow Camera Access</span></div>
    
    <div id="ui">
        <div class="state-indicator" id="status-text">Waiting for vision...</div>
        <br>
        <div class="instruction">üëã Open Hand: Disperse Seeds</div>
        <div class="instruction">ü§è Pinch: Coax Bloom</div>
        <div class="instruction">ü§ú Fist: Time Freeze</div>
        <div class="instruction">‚ö†Ô∏è Fast Motion: Disrupt Harmony</div>
    </div>

    <video id="video-input" autoplay playsinline></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker, FaceLandmarker, DrawingUtils } from '@mediapipe/tasks-vision';

        // --- Configuration ---
        const PARTICLE_COUNT = 8000;
        const CAM_SENSITIVITY = 0.5;
        const INTERACTION_RADIUS = 30;
        
        // --- State ---
        let handLandmarker = undefined;
        let faceLandmarker = undefined;
        let webcamRunning = false;
        let lastVideoTime = -1;
        let handPos = new THREE.Vector3(0, 0, 0);
        let handVelocity = 0;
        let lastHandPos = new THREE.Vector3(0,0,0);
        let gesture = "NONE"; // NONE, OPEN, PINCH, FIST
        let harmonyLevel = 1.0; // 1.0 = calm, 0.0 = chaotic

        // --- Three.js Globals ---
        let scene, camera, renderer, composer, particles, particleGeo, clock;
        let particleData = []; // Store physics data per particle

        // --- UI Elements ---
        const video = document.getElementById('video-input');
        const statusText = document.getElementById('status-text');
        const loadingDiv = document.getElementById('loading');

        // ==========================================
        // 1. SYSTEM INITIALIZATION
        // ==========================================

        async function init() {
            // Setup Vision AI
            await setupVision();
            
            // Setup 3D World
            setupThreeJS();
            
            // Start Camera
            startWebcam();
            
            // Remove loader
            loadingDiv.style.display = 'none';
            video.style.display = 'block';

            // Start Loop
            animate();
        }

        async function setupVision() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm"
            );

            // Hand Tracking
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });

            // Face Tracking (for Head Parallax)
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                    delegate: "GPU"
                },
                outputFaceBlendshapes: false,
                runningMode: "VIDEO",
                numFaces: 1
            });
        }

        function setupThreeJS() {
            const container = document.getElementById('canvas-container');
            
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000510, 0.015); // Deep misty fog
            scene.background = new THREE.Color(0x000510);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;
            camera.position.y = 10;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // Post Processing (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.8; // High glow
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Particles (The Forest)
            createForest();

            // Lighting
            const ambient = new THREE.AmbientLight(0x404040);
            scene.add(ambient);

            clock = new THREE.Clock();

            // Resize Handler
            window.addEventListener('resize', onWindowResize);
        }

        function createForest() {
            particleGeo = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];

            const colorBase = new THREE.Color();
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Generate a wavy forest floor shape
                const x = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 60;
                const y = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 5 + (Math.random() * 10) - 5;

                positions.push(x, y, z);

                // Bioluminescent Colors (Teal/Purple/Blue)
                const r = Math.random();
                if(r > 0.5) colorBase.setHSL(0.5 + Math.random() * 0.1, 0.8, 0.6); // Cyan/Blue
                else colorBase.setHSL(0.75 + Math.random() * 0.1, 0.8, 0.6); // Purple

                colors.push(colorBase.r, colorBase.g, colorBase.b);
                sizes.push(Math.random() * 0.5);

                // Physics State
                particleData.push({
                    originalPos: new THREE.Vector3(x, y, z),
                    velocity: new THREE.Vector3(0, 0, 0),
                    noiseOffset: Math.random() * 100
                });
            }

            particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            particleGeo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            // Custom Shader Material for glowing dots
            const material = new THREE.PointsMaterial({
                size: 0.8,
                vertexColors: true,
                map: createCircleTexture(),
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(particleGeo, material);
            scene.add(particles);
        }

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const center = 16;
            const gradient = context.createRadialGradient(center, center, 0, center, center, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0,0,32,32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function startWebcam() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } })
                .then(stream => {
                    video.srcObject = stream;
                    video.addEventListener('loadeddata', () => { webcamRunning = true; });
                });
            }
        }

        // ==========================================
        // 2. LOGIC LOOP
        // ==========================================

        function animate() {
            requestAnimationFrame(animate);

            let deltaTime = clock.getDelta();
            let now = performance.now();

            if (webcamRunning && lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                
                // 1. Detect Hand
                if (handLandmarker) {
                    const handResult = handLandmarker.detectForVideo(video, now);
                    processHand(handResult);
                }

                // 2. Detect Face (Head)
                if (faceLandmarker) {
                    const faceResult = faceLandmarker.detectForVideo(video, now);
                    processFace(faceResult);
                }
            }

            updateForest(deltaTime);
            composer.render();
        }

        // ==========================================
        // 3. INTERACTION LOGIC
        // ==========================================

        function processFace(result) {
            if(result.faceLandmarks.length > 0) {
                // Get nose tip (index 1) normalized coordinates
                const nose = result.faceLandmarks[0][1]; 
                
                // Map webcam coords (0-1) to slight camera movement
                // x is inverted in webcam
                const targetX = (0.5 - nose.x) * 10; 
                const targetY = (0.5 - nose.y) * 5 + 10; 
                
                // Smooth Lerp
                camera.position.x += (targetX - camera.position.x) * 0.05;
                camera.position.y += (targetY - camera.position.y) * 0.05;
                camera.lookAt(0, 0, 0);
            }
        }

        function processHand(result) {
            if (result.landmarks.length > 0) {
                const landmarks = result.landmarks[0];
                
                // Calculate Hand Position in 3D world approximation
                // Map x/y (0-1) to scene coords (-40 to 40)
                const x = (0.5 - landmarks[9].x) * 80; // Middle finger knuckle as center
                const y = (0.5 - landmarks[9].y) * 50;
                
                // Update Vector
                handPos.set(x, y, 10); // Assume z plane at 10

                // Calculate Speed (Distance moved per frame)
                const speed = handPos.distanceTo(lastHandPos);
                handVelocity = speed;
                lastHandPos.copy(handPos);

                // Gesture Detection
                detectGesture(landmarks);
            } else {
                // Reset if no hand
                handVelocity = 0;
                gesture = "NONE";
                // Slowly return harmony
                if(harmonyLevel < 1.0) harmonyLevel += 0.01;
            }
        }

        function detectGesture(lm) {
            // Finger Tips
            const thumbTip = lm[4];
            const indexTip = lm[8];
            const middleTip = lm[12];
            const ringTip = lm[16];
            const pinkyTip = lm[20];
            const wrist = lm[0];

            // 1. PINCH (Thumb tip close to Index tip)
            const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            
            // 2. FIST (All tips close to wrist)
            const avgDistToWrist = (
                Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y) +
                Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y) +
                Math.hypot(ringTip.x - wrist.x, ringTip.y - wrist.y) +
                Math.hypot(pinkyTip.x - wrist.x, pinkyTip.y - wrist.y)
            ) / 4;

            if (pinchDist < 0.05) {
                gesture = "PINCH";
                statusText.innerText = "üå∏ Blooming";
            } else if (avgDistToWrist < 0.15) {
                gesture = "FIST";
                statusText.innerText = "‚è∏Ô∏è Holding Time";
            } else {
                gesture = "OPEN";
                statusText.innerText = "üçÉ Dispersing";
            }

            // Check Harmony (Velocity)
            if (handVelocity > 1.5) { // Fast movement threshold
                harmonyLevel = Math.max(0, harmonyLevel - 0.05); // Reduce harmony
                statusText.innerText = "‚ö° Disrupting!";
            } else {
                harmonyLevel = Math.min(1, harmonyLevel + 0.01); // Restore harmony
            }
        }

        // ==========================================
        // 4. PHYSICS SIMULATION
        // ==========================================

        function updateForest(dt) {
            const positions = particleGeo.attributes.position.array;
            const colors = particleGeo.attributes.color.array;
            const time = Date.now() * 0.001;

            // Harmony Color Targets
            // Calm = Cyan/Green, Stress = Red/Orange
            const calmColor = new THREE.Color(0x00ffcc);
            const stressColor = new THREE.Color(0xff3300);
            const currentColor = new THREE.Color().lerpColors(stressColor, calmColor, harmonyLevel);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const data = particleData[i];

                // 1. Base Float (Perlin-ish noise approximation)
                if (gesture !== "FIST") {
                    data.originalPos.y += Math.sin(time + data.noiseOffset) * 0.02 * harmonyLevel;
                }

                // 2. Interactions
                const px = positions[i3];
                const py = positions[i3 + 1];
                const pz = positions[i3 + 2];
                
                const distToHand = Math.sqrt(
                    (px - handPos.x) ** 2 + 
                    (py - handPos.y) ** 2 + 
                    (pz - handPos.z) ** 2
                );

                const force = new THREE.Vector3(0, 0, 0);

                if (distToHand < INTERACTION_RADIUS && gesture !== "NONE") {
                    const dx = px - handPos.x;
                    const dy = py - handPos.y;
                    const dz = pz - handPos.z;

                    if (gesture === "OPEN") {
                        // Repel (Wind)
                        const strength = (1 - distToHand / INTERACTION_RADIUS) * 20 * dt;
                        force.set(dx, dy, dz).normalize().multiplyScalar(strength);
                    } else if (gesture === "PINCH") {
                        // Attract (Bloom/Gather)
                        const strength = (1 - distToHand / INTERACTION_RADIUS) * 30 * dt;
                        force.set(-dx, -dy, -dz).normalize().multiplyScalar(strength);
                    } else if (gesture === "FIST") {
                        // Dampen velocity to zero
                        data.velocity.multiplyScalar(0.8); 
                    }
                    
                    // Add Disruption turbulence
                    if (harmonyLevel < 0.5) {
                        force.add(new THREE.Vector3(
                            (Math.random()-0.5)*2, 
                            (Math.random()-0.5)*2, 
                            (Math.random()-0.5)*2
                        ));
                    }
                }

                // Apply Force to Velocity
                data.velocity.add(force);

                // Apply Return-to-origin Spring force (Elasticity)
                const returnForce = new THREE.Vector3()
                    .subVectors(data.originalPos, new THREE.Vector3(px, py, pz))
                    .multiplyScalar(0.05 * harmonyLevel); // Less elastic when chaotic
                
                data.velocity.add(returnForce);

                // Apply Friction/Damping
                data.velocity.multiplyScalar(0.92);

                // Update Position
                positions[i3] += data.velocity.x;
                positions[i3 + 1] += data.velocity.y;
                positions[i3 + 2] += data.velocity.z;

                // Update Color based on individual velocity (Stress) and Global Harmony
                const speed = data.velocity.length();
                const pColor = new THREE.Color(currentColor);
                
                // If moving fast locally, flash white
                if (speed > 0.5) pColor.setHex(0xffffff);

                colors[i3] = pColor.r;
                colors[i3+1] = pColor.g;
                colors[i3+2] = pColor.b;
            }

            particleGeo.attributes.position.needsUpdate = true;
            particleGeo.attributes.color.needsUpdate = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

    </script>
</body>
</html>
