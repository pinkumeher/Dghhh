<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pinku Iron Man Controller</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            pointer-events: none;
            background: rgba(10, 10, 20, 0.8);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #00ddee;
            box-shadow: 0 0 25px rgba(0, 221, 238, 0.3);
            width: 280px;
            backdrop-filter: blur(5px);
        }
        
        h1 { margin: 0; font-size: 1.5rem; text-transform: uppercase; letter-spacing: 1px;
             background: linear-gradient(90deg, #ff0055, #ffcc00); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        h2 { margin: 5px 0 15px 0; font-size: 0.9rem; color: #00ddee; font-weight: normal; text-transform: uppercase; }

        .data-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.9rem; }
        .data-val { font-weight: bold; color: #ffcc00; }
        
        #webcam-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            transform: scaleX(-1);
            border: 2px solid #ff0055;
            border-radius: 8px;
            opacity: 0.6;
        }

        .instruction { color: #00ffaa; font-weight: bold; }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-container">
        <h1>Pinku AI</h1>
        <h2>Particle Controller</h2>
        
        <div style="border-top: 1px solid #444; margin: 10px 0;"></div>
        
        <div class="data-row">
            <span>ACTIVE MODEL:</span>
            <span id="shape-name" class="data-val">LOADING...</span>
        </div>
        
        <div style="margin-top: 15px; font-size: 0.8rem; color: #aaa;">
            <p>üëã Move Hand to Rotate</p>
            <p>ü§è <span class="instruction">Pinch</span> to Assemble</p>
            <p>üñê <span class="instruction">Open</span> to Explode</p>
            <p>‚úä <span class="instruction">FIST</span> to Switch Model</p>
        </div>
    </div>

    <video id="webcam-feed" autoplay playsinline></video>

<script>
    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 22000;
    const PARTICLE_SIZE = 0.08;
    const SMOOTHING = 0.08; 
    
    // --- THREE.JS SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 18;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- PARTICLE SYSTEM ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
    
    // Init random
    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 100;
        targetPositions[i] = positions[i];
        colors[i] = 1.0;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.9
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);

    // ==========================================
    //          SHAPE ALGORITHMS
    // ==========================================

    // 1. PINKU TEXT
    function getPinkuTextPoint(i) {
        const P = [[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0]];
        const I = [[0,1,1,1,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,1,1,1,0]];
        const N = [[1,0,0,0,1],[1,1,0,0,1],[1,0,1,0,1],[1,0,0,1,1],[1,0,0,0,1]];
        const K = [[1,0,0,1,0],[1,0,1,0,0],[1,1,0,0,0],[1,0,1,0,0],[1,0,0,1,0]];
        const U = [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]];

        const letters = [P, I, N, K, U];
        const spacing = 6;
        const scale = 0.8;
        const startX = -((letters.length * spacing) / 2) + 2;
        const letterIdx = i % letters.length;
        const grid = letters[letterIdx];
        
        let found = false, px=0, py=0;
        let attempt = 0;
        while(!found && attempt < 15) {
            const r = Math.floor(Math.random()*5);
            const c = Math.floor(Math.random()*5);
            if(grid[r][c]===1) {
                px = (c*scale) + (startX + letterIdx*spacing) + (Math.random()-0.5)*0.5;
                py = ((4-r)*scale) - 2 + (Math.random()-0.5)*0.5;
                found = true;
            }
            attempt++;
        }
        if(!found) return {x:(Math.random()-0.5)*10, y:(Math.random()-0.5)*10, z:0};
        return { x: px, y: py, z: (Math.random()-0.5)*2 };
    }

    // 2. IRON MAN HAND
    function getIronManHandPoint(i) {
        const r = Math.random();
        // Repulsor (10%)
        if (r < 0.10) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 1.3; 
            return { x: Math.cos(angle)*radius, y: Math.sin(angle)*radius, z: 1.0 + Math.random() };
        }
        // Palm/Arm (40%)
        else if (r < 0.50) {
            if (Math.random() > 0.5) {
                return { x: (Math.random()-0.5)*5, y: (Math.random()-0.5)*4.5, z: (Math.random()-0.5)*1.5 - 1 };
            } else {
                const angle = Math.random() * Math.PI * 2;
                const z = -2 - (Math.random() * 8);
                return { x: Math.cos(angle)*3.2, y: Math.sin(angle)*2.8, z: z };
            }
        }
        // Fingers (50%)
        else {
            const fIdx = Math.floor(Math.random() * 5);
            const seg = Math.random(); 
            let fx, fy, fz;
            if (fIdx === 0) { // Thumb
                fx = -3 - (seg * 2.5); fy = -1 + (seg * 2.5); fz = 0;
            } else {
                let xBase = 0, yStart = 2.5, len = 4;
                if (fIdx===1) { xBase=-1.8; len=4.0; }
                if (fIdx===2) { xBase=0; len=4.5; }
                if (fIdx===3) { xBase=1.8; len=4.0; }
                if (fIdx===4) { xBase=3.4; yStart=1.5; len=3.0; }
                fx = xBase; fy = yStart + (seg*len); fz = (seg*seg)*1.5;
            }
            return { x: fx + (Math.random()-0.5), y: fy + (Math.random()-0.5)*0.5, z: fz + (Math.random()-0.5) };
        }
    }

    // 3. SUDARSHAN CHAKRA
    function getChakraPoint(i) {
        const angle = Math.random() * Math.PI * 2;
        const rBase = 6 + Math.random() * 1.5;
        const spikes = 12;
        const spikeH = Math.abs(Math.sin(angle * spikes)) * 2.5;
        const r = rBase + spikeH;
        return { x: Math.cos(angle)*r, y: Math.sin(angle)*r, z: (Math.random()-0.5)*0.2 };
    }

    // 4. TRISHUL
    function getTrishulPoint(i) {
        const c = Math.random();
        if (c < 0.6) return { x: (Math.random()-0.5)*0.5, y: (Math.random()*16)-10, z: (Math.random()-0.5)*0.5 };
        else if (c < 0.8) {
            const t = Math.random()*Math.PI;
            return { x: Math.cos(t)*2.5 + (t>Math.PI/2?-2.5:2.5), y: 4+Math.sin(t)*4, z: (Math.random()-0.5)*0.3 };
        }
        else return { x: (Math.random()-0.5)*0.4, y: 6+Math.random()*4, z: (Math.random()-0.5)*0.4 };
    }

    // 5. BRAHMASTRA (Torus Knot)
    function getBrahmastraPoint(i) {
        const t = (i/PARTICLE_COUNT)*Math.PI*2*15;
        const p=2, q=3, scale=2.8;
        const r = 2 + Math.cos(q*t);
        return { x: scale*r*Math.cos(p*t), y: scale*r*Math.sin(p*t), z: scale*Math.sin(q*t) };
    }

    // 6. AEROPLANE
    function getPlanePoint(i) {
        const r = Math.random();
        if (r < 0.5) { // Body
            const z = (Math.random()*12)-6;
            const a = Math.random()*6.28;
            return { x: Math.cos(a)*1.2, y: Math.sin(a)*1.2, z: z };
        } else if (r < 0.8) { // Wings
            const x = (Math.random()*14)-7;
            const z = (Math.random()*4)-1;
            return { x: x, y: 0, z: z * (1 - Math.abs(x)/10) };
        } else { // Tail
            return { x: (Math.random()-0.5)*4, y: Math.random()*3, z: -5+(Math.random()*2) };
        }
    }

    // 7. BOW & ARROW
    function getBowPoint(i) {
        if(Math.random()<0.6) {
             const t = (Math.random()*Math.PI)-Math.PI/2;
             return { x: Math.cos(t)*1.5, y: Math.sin(t)*8, z: 0 };
        } else {
             return { x: (Math.random()*10)-5, y: 0, z: 0 };
        }
    }

    // MATH SHAPES
    function getSpherePoint(i) {
        const u = Math.random(), v = Math.random();
        const t = 2*Math.PI*u, p = Math.acos(2*v-1), r=6;
        return { x: r*Math.sin(p)*Math.cos(t), y: r*Math.sin(p)*Math.sin(t), z: r*Math.cos(p) };
    }
    function getDNAPoint(i) {
        const y = ((i/PARTICLE_COUNT)*14)-7;
        const a = y*4, off = (i%2===0)?0:3.14;
        return { x: Math.cos(a+off)*3, y: y, z: Math.sin(a+off)*3 };
    }
    function getCubePoint(i) {
        return { x: (Math.random()-0.5)*8, y: (Math.random()-0.5)*8, z: (Math.random()-0.5)*8 };
    }
    function getPyramidPoint(i) {
        const y = (Math.random()*10)-5;
        const s = 7 * (1 - (y+5)/10);
        return { x: (Math.random()-0.5)*2*s, y: y, z: (Math.random()-0.5)*2*s };
    }
    function getHeartPoint(i) {
        const t = (Math.random()*6.28)-3.14, s=0.35;
        const r = 16*Math.pow(Math.sin(t),3);
        const y = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
        return { x: r*s, y: y*s, z: (Math.random()-0.5)*4 };
    }
    function getWavePoint(i) {
        const x=(Math.random()-0.5)*12, z=(Math.random()-0.5)*12;
        return { x:x, y: Math.sin(x)*Math.cos(z)*2, z:z };
    }
    function getGalaxyPoint(i) {
        const arms=5, maxR=9, r=Math.random()*maxR;
        const a = (r/maxR)*Math.PI*2*4 + ((i%arms)*(6.28/arms));
        return { x: Math.cos(a)*r, y: (Math.random()-0.5)*(maxR-r)*0.5, z: Math.sin(a)*r };
    }

    // ==========================================
    //           MANAGER & COLOR LOGIC
    // ==========================================
    const shapes = [
        { name: 'Pinku AI (Name)', func: getPinkuTextPoint },
        { name: 'Iron Man Hand', func: getIronManHandPoint },
        { name: 'Sudarshan Chakra', func: getChakraPoint },
        { name: 'Trishul (Shiva)', func: getTrishulPoint },
        { name: 'Brahmastra', func: getBrahmastraPoint },
        { name: 'Aeroplane', func: getPlanePoint },
        { name: 'Bow & Arrow', func: getBowPoint },
        { name: 'Sphere', func: getSpherePoint },
        { name: 'DNA Helix', func: getDNAPoint },
        { name: 'Quantum Cube', func: getCubePoint },
        { name: 'Ancient Pyramid', func: getPyramidPoint },
        { name: 'Heart', func: getHeartPoint },
        { name: 'Sine Wave', func: getWavePoint },
        { name: 'Galaxy', func: getGalaxyPoint }
    ];

    let currentShapeIndex = 0;

    function updateTargetShape() {
        const s = shapes[currentShapeIndex];
        document.getElementById('shape-name').innerText = s.name;
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const p = s.func(i);
            targetPositions[i*3] = p.x;
            targetPositions[i*3+1] = p.y;
            targetPositions[i*3+2] = p.z;
        }
        applyColors();
    }

    function applyColors() {
        const c = geometry.attributes.color;
        const name = shapes[currentShapeIndex].name;
        
        for(let i=0; i<PARTICLE_COUNT; i++) {
            // IRON MAN COLORING
            if(name === 'Iron Man Hand') {
                const tx = targetPositions[i*3], ty = targetPositions[i*3+1];
                const dist = Math.sqrt(tx*tx + ty*ty);
                // Repulsor (Center) -> Blue/White
                if (dist < 1.6 && targetPositions[i*3+2] > 0) {
                    c.setXYZ(i, 0.5, 0.9, 1.0); // Cyan/White
                } else {
                    // Armor -> Red & Gold
                    if(Math.random() > 0.35) c.setXYZ(i, 0.8, 0.1, 0.1); // Red
                    else c.setXYZ(i, 1.0, 0.8, 0.1); // Gold
                }
            } 
            // WEAPONS (Gold/Fire)
            else if(name.includes('Chakra') || name.includes('Trishul') || name.includes('Brahmastra')) {
                c.setXYZ(i, 1.0, 0.4 + Math.random()*0.6, 0.0);
            }
            // PINKU (Pink/Purple)
            else if(name.includes('Pinku')) {
                c.setXYZ(i, 1.0, 0.2, 0.8 + Math.random()*0.2);
            }
            // DEFAULT (Rainbow/Neon)
            else {
                c.setXYZ(i, Math.random(), 0.5+Math.random()*0.5, 1.0);
            }
        }
        c.needsUpdate = true;
    }

    updateTargetShape();

    // ==========================================
    //          TRACKING & ANIMATION
    // ==========================================
    let pinchStrength = 0;
    let handX = 0, handY = 0;
    let isFist = false, lastFistTime = 0;

    const videoElement = document.getElementById('webcam-feed');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });

    hands.onResults((results) => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            
            // 1. Rotation (Index Finger Tip)
            handX += ((lm[8].x - 0.5) * 2 - handX) * 0.1;
            handY += (-(lm[8].y - 0.5) * 2 - handY) * 0.1;

            // 2. Pinch (Thumb vs Index)
            const d = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
            pinchStrength = 1 - Math.min(Math.max(d/0.15, 0), 1);

            // 3. Fist (Tips below knuckles)
            let curled = 0;
            if(lm[8].y > lm[6].y) curled++;
            if(lm[12].y > lm[10].y) curled++;
            if(lm[16].y > lm[14].y) curled++;
            if(lm[20].y > lm[18].y) curled++;

            const now = Date.now();
            if (curled >= 3) {
                if (!isFist && now - lastFistTime > 1200) {
                    currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
                    updateTargetShape();
                    lastFistTime = now;
                }
                isFist = true;
            } else {
                isFist = false;
            }
        }
    });

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    // Loop
    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        const pos = geometry.attributes.position.array;

        // Visual Interaction
        particleSystem.rotation.y = -handX * 2.5;
        particleSystem.rotation.x = handY * 2.5;
        
        // Spin logic for Chakra
        if(shapes[currentShapeIndex].name.includes('Chakra')) particleSystem.rotation.z += 0.1;
        else particleSystem.rotation.z *= 0.9;

        // Pinch Expansion Logic
        const expand = 1 + (1 - pinchStrength) * 3;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i*3;
            let tx = targetPositions[ix] * expand;
            let ty = targetPositions[ix+1] * expand;
            let tz = targetPositions[ix+2] * expand;

            // Explosion Noise
            if (pinchStrength < 0.2) {
                tx += Math.sin(time*5+i)*0.5; ty += Math.cos(time*4+i)*0.5;
            }

            pos[ix] += (tx - pos[ix]) * SMOOTHING;
            pos[ix+1] += (ty - pos[ix+1]) * SMOOTHING;
            pos[ix+2] += (tz - pos[ix+2]) * SMOOTHING;
        }

        geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
